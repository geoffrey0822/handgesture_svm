function gestureReongnitionRT_signLang()

close all;
clear all;

% % % t=tcpip('0.0.0.0',30000,'NetworkRole','server');
% % % fopen(t);
% % % fwrite(t,2);

% cform=makecform('srgb2lab');
cform = makecform('srgb2lab', 'AdaptedWhitePoint', whitepoint('D65'));
se = strel('disk',5);
m_sampleSize=[200 200];
m_slideStep=[80 80];
m_cellSize=[16 16];
m_blockSize=[4 4];
m_blockOverlap=ceil(m_blockSize/2);
m_detectionWin=[(640-480)/2 0 480 480];
m_classMap={'','Friend','Game','Coffee'};

[svm1,svm2]=loadSVM('./exp/svm/sign_front.mat');
cam=imaq.VideoDevice('winvideo',1);
camInfo=cam.DeviceProperties;
cam.DeviceProperties.WhiteBalanceMode='manual';
cam.DeviceProperties.WhiteBalance=2800;
cam.DeviceProperties.Gamma=100;
cam.DeviceProperties.Contrast=20;
cam.DeviceProperties.BacklightCompensation='off';
disp(camInfo);


I=step(cam);
I=imresize(I,[480 640]);
% h=imagesc(I);
h=imshow(I);
set(h,'EraseMode','none');

while(1)
    img=step(cam);
    img=imresize(img,[480 640]);
    dispI=preprocessImage(im2uint8(img),cform,se);
%     dispIY=slide_pose_detect(dispI,{svm1,svm2},m_cellSize,m_blockSize,m_blockOverlap,m_sampleSize,m_slideStep);
    [dispIY,bestLabel]=multiScale_pose_detect(dispI,{svm1,svm2},m_cellSize,m_blockSize,m_blockOverlap,m_sampleSize,m_detectionWin,...
        [0.7 0.6 0.5 0.45 0.4],m_classMap,im2uint8(img));
    if bestLabel>1
%         fwrite(t,sprintf('Action:%d\n',bestLabel));
% % % % % fwrite(t,bestLabel);
%         if exist('./exp/userUpdate.txt','file')==2
%             fid=fopen('./exp/userUpdate.txt','w');
%             fprintf(fid,'%d',bestLabel);
%             fclose(fid);
%         end
%         disp(m_classMap{bestLabel});
    end
%     set(h,'CData',dispI);
    set(h,'CData',dispIY);
    
    pause(30/1000);
end

% % % % fclose(t);
fclose('all');

end

function [svm1,svm2]=loadSVM(file)

data=load(file);
svm1=data.m_ssvm;
svm2=data.m_ssvm2;

end

function y=preprocessImage(x,cform,se)
% px=im2double(x);
% px=applycform(px,cform);
% px=im2uint8(colorspace('lab<-rgb',im2double(x)));

[BW,px]=createMask_YCbCr(x,se);
% [BW,px]=createMask_Lab(x,cform,se);

y=px;

end



function [BW,maskedRGBImage] = createMask_Lab(RGB,cform,se)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder App. The colorspace and
%  minimum/maximum values for each channel of the colorspace were set in the
%  App and result in a binary mask BW and a composite image maskedRGBImage,
%  which shows the original RGB image values under the mask BW.

% Auto-generated by colorThresholder app on 13-Nov-2016
%------------------------------------------------------


% Convert RGB image to chosen color space
RGB = im2double(RGB);
I = applycform(RGB,cform);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.000;
channel1Max = 100.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 10.652;
channel2Max = 32.636;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 6.001;
channel3Max = 26.246;

% Create mask based on chosen histogram thresholds
BW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);


BW=imdilate(BW,se);
% BW=imfill(BW,'holes');

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
maskedRGBImage=im2uint8(maskedRGBImage);

end

function [outImg,bestLabel]=multiScale_pose_detect(src,learners,cellSize,blockSize,blockOverlap,detectionSize,winRect,scales,classMap,raw)

[fImg,edge,color]=pose_imgProc(src);
lnSize=size(learners,2);

bg=zeros(detectionSize(1),detectionSize(2),3);
nScale=numel(scales);
i=1;
boundingBox=[];
labels={};
best_matched=[];
best_label=[];
bestLabel=1;
c=1;
while i<nScale
    s_winRect=winRect*scales(i);
    s_winRect(2)=s_winRect(2)+winRect(4)-s_winRect(4);
    s_winRect(1)=s_winRect(1)+winRect(3)-s_winRect(3);
    roi_img=imcrop(color,s_winRect);
    roi_edge=imcrop(edge,s_winRect);
    roi_img=imresize(roi_img,detectionSize);
    roi_edge=imresize(roi_edge,detectionSize);
    [~,~,featColor,featShape]=getFeatureVector(roi_img,roi_edge,cellSize,blockSize,blockOverlap,roi_img);
        featuresArr={featColor;featShape};
    
    total_score=0;
    for j=1:lnSize
        [tclass,score]=predict(learners{j},featuresArr{j},'BinaryLoss','binodeviance','PosteriorMethod','gp');
        if j==1
            total_score=score;
        else
            total_score=total_score+score;
        end
    end
    total_score=total_score/lnSize;
    [v,idx]=max(total_score);
        %% best threshold in home is >-0.2
    if idx>1 && v>-0.25
        best_matched(c)=total_score(idx);
        boundingBox(c,:)=s_winRect;
        boundingBox(c,4)=boundingBox(c,4)-20;
        best_label(c)=idx;
%         labels{c}=sprintf('%s (Score:%f)',classMap{idx},total_score(idx));
        labels{c}=sprintf('%s',classMap{idx});
        c=c+1;
    end
    i=i+1;
end
fImg=raw;
if ~isempty(boundingBox)
    [maxV,maxIdx]=max(best_matched);
%     fImg=insertObjectAnnotation(raw,'rectangle',boundingBox,labels,'LineWidth',3,'TextBoxOpacity',0.9,'Color',[0 255 0]);
%     fImg=insertObjectAnnotation(raw,'rectangle',boundingBox(maxIdx,:),labels{maxIdx},'LineWidth',3,'TextBoxOpacity',0.9,'Color',[0 255 0]);
    fImg=insertText(fImg,[320,400],labels{maxIdx},'FontSize',24);
    bestLabel=best_label(maxIdx);
end
outImg=fImg;

end

function outImg=slide_pose_detect(src,learners,cellSize,blockSize,blockOverlap,winSize,slideSize)

[fImg,edge,color]=pose_imgProc(src);
lnSize=size(learners,2);

x=1;
y=1;

g_width=size(src,2);
g_height=size(src,1);
end_width=winSize(1);
end_height=winSize(2);

while y<g_height
    end_width=winSize(1);
    x=1;
    while x<g_width
        roi_img=imcrop(color,[x y winSize(1) winSize(2)]);
        roi_edge=imcrop(edge,[x y winSize(1) winSize(2)]);
        [~,~,featColor,featShape]=getFeatureVector(roi_img,roi_edge,cellSize,blockSize,blockOverlap,roi_img);
        featuresArr={featColor;featShape};
        
        x=x+slideSize(1);
        end_width=x+winSize(1);
    end
    y=y+slideSize(2);
    end_height=y+winSize(2);
    
end

outImg=fImg;
end


function [class,score,outImg]=pose_detect(src,learners,...
    cellSize,blockSize,blockOverlap)
    [fImg,edge,color]=pose_imgProc(src);
    ax=1;
    ay=1;
    lnSize=size(learners,2);
    owSize=size(edge,2);
    ohSize=size(edge,1);
    wSize=size(src,2);
    hSize=size(src,1);
    features=[];
    dataColor=[];
    dataEdge=[];
    outImg=fImg;
    learner=[];
    partialMatched=false;
    message='';
    dataColor=color;
    dataEdge=edge;
    score=0;
    [features,~,featColor,featShape]=getFeatureVector(dataColor,dataEdge,cellSize,blockSize,blockOverlap,src);
    featuresArr={featColor;featShape};
    class=-1;
    labelName='';
    totalScore=[];
    for i=1:lnSize
        learner=learners{i};
        [tclass,score]=predict(learner,featuresArr{i},'BinaryLoss','binodeviance','PosteriorMethod','gp');
        if i==1
            totalScore=score;
        else
            totalScore=(totalScore+score)/2.0;
        end
        if(tclass~=-1)
            if(class==-1)
                class=tclass;
            elseif(class~=tclass)
                if(class~=-1)
                    partialMatched=true;
                    if(i==1)
                        message='Color Matched';
                    else
                        message='Shape Matched';
                    end
                end
                class=-1;
            end
        else
            break;
        end
    end
    score=totalScore;
    if(class~=-1)
        labelName=sprintf('pose %d',class);
    end
    if(class~=-1)
        outImg=insertObjectAnnotation(outImg,'Rectangle',[ax ay wSize hSize],'pose 1',...
            'TextBoxOpacity',0.9,'Color',[0 255 0]);
        outImg=insertText(outImg,[1 1],labelName,'BoxColor',[0 255 0]);
    elseif partialMatched==true
        outImg=insertObjectAnnotation(outImg,'Rectangle',[ax ay wSize hSize],'Confused',...
            'TextBoxOpacity',0.9,'Color',[255,0,0]);
        outImg=insertText(outImg,[1 1],'Confused','BoxColor',[255 0 0]);
    end
    
end

function [y,BW,segment]=pose_imgProc(raw)
mask=im2bw(raw,0);
segment2=raw;
BW=edge(rgb2gray(segment2),'Canny',0.02);

regionMask=mask;
regionImg=raw;
regionEdge=bitand(BW,regionMask);
BW=regionEdge;
segment=regionImg;
y=overlayMask(regionImg,regionEdge);
end

%% Segmentation
function [BW,maskedRGBImage] = createMask_YCbCr(RGB,se)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder App. The colorspace and
%  minimum/maximum values for each channel of the colorspace were set in the
%  App and result in a binary mask BW and a composite image maskedRGBImage,
%  which shows the original RGB image values under the mask BW.

% Auto-generated by colorThresholder app on 13-Nov-2016
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2ycbcr(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.000;
channel1Max = 255.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 108.000;
channel2Max = 150.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 136.000;
channel3Max = 255.000;

% Create mask based on chosen histogram thresholds
BW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);

% BW=imerode(BW,strel('disk',5));
BW=imdilate(BW,se);
% BW=imfill(BW,'holes');
% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
end